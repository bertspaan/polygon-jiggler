/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const IMAGE_URL = '510d47e0-bf3e-a3d9-e040-e00a18064a99.jpg'\n\n//\n//\n// const url = '510d47e0-bf3e-a3d9-e040-e00a18064a99.jpg'\n//\n// const polygonCanvas = document.getElementById('polygon-canvas')\n// const polygonCtx = polygonCanvas.getContext('2d')\n//\n// const imageElement = document.getElementById('image')\n//\n// const img = new Image\n//\n// let imageCanvas\n//\n// let workerRunning = false\n//\n// let polygon = []\n// let drawing = true\n//\n// let worker\n//\n// function startJiggling () {\n//   worker = new Worker('worker.js')\n//\n//   worker.addEventListener('error', (event) => {\n//     console.error(event.message)\n//   })\n//\n//   worker.addEventListener('message', (event) => {\n//     if (event && event.data) {\n//       const results = event.data\n//\n//       polygon = event.data.polygon\n//       const scores = event.data.scores\n//       draw(polygon, scores)\n//     } else {\n//       workerRunning = false\n//     }\n//   })\n//\n//   const imageData = imageCanvas.getContext('2d').getImageData(0, 0, imageCanvas.width, imageCanvas.height)\n//   const buffer = imageData.data.buffer\n//\n//   worker.postMessage({\n//     stepCount: 1000,\n//     buffer,\n//     dimensions: [imageData.width, imageData.height],\n//     polygon\n//   }, [buffer])\n//\n//   workerRunning = true\n//   // window.requestAnimationFrame(step)\n// }\n//\n// // function step (timestamp) {\n// //   draw(polygon)\n// //\n// //   if (running) {\n// //     window.requestAnimationFrame(step)\n// //   }\n// // }\n//\n// img.addEventListener('load', () => {\n//   polygonCanvas.height = img.height\n//   polygonCanvas.width = img.width\n//\n//   polygonCanvas.style.height = img.height + 'px'\n//   polygonCanvas.style.width = img.width + 'px'\n//\n//   imageElement.src = url\n//\n//   imageCanvas = document.createElement('canvas')\n//   imageCanvas.width = img.width\n//   imageCanvas.height = img.height\n//   imageCanvas.getContext('2d').drawImage(img, 0, 0, img.width, img.height)\n// })\n//\n// img.src = url\n//\n// function getLineColor (value, alpha=0.9) {\n//   const r = Math.round(255 * value)\n//   const g = Math.round(255 * (1 - value))\n//   const b = 0\n//   return `rgba(${r}, ${g}, ${b}, ${alpha})`\n// }\n//\n// function draw (polygon, scores) {\n//   polygonCtx.clearRect(0, 0, polygonCanvas.width, polygonCanvas.height)\n//\n//   polygonCtx.beginPath()\n//\n//   const lineWidth = 5\n//\n//   polygonCtx.lineWidth = lineWidth\n//   polygonCtx.fillStyle = 'red'\n//\n//   if (polygon.length > 1) {\n//     polygon.slice(1)\n//       .forEach((point, index) => {\n//         if (scores && scores[index]) {\n//           polygonCtx.strokeStyle = getLineColor(scores[index])\n//         } else {\n//           polygonCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)'\n//         }\n//\n//         polygonCtx.beginPath()\n//\n//         const pointA = polygon[index]\n//         const pointB = polygon[index + 1]\n//\n//         polygonCtx.moveTo(pointA[0], pointA[1])\n//         polygonCtx.lineTo(pointB[0], pointB[1])\n//         polygonCtx.stroke()\n//       })\n//   }\n//\n//   polygonCtx.lineWidth = 0\n//   polygonCtx.fillStyle = 'black'\n//\n//   polygon.forEach((point) => {\n//     polygonCtx.beginPath()\n//     polygonCtx.arc(point[0], point[1], lineWidth * 2, 0, 2 * Math.PI)\n//     polygonCtx.fill()\n//   })\n//\n//   polygonCtx.stroke()\n// }\n//\n// function distance (pointA, pointB) {\n//   const dX = pointA[0] - pointB[0]\n//   const dY = pointA[1] - pointB[1]\n//   return Math.sqrt(Math.pow(dX, 2) + Math.pow(dY, 2))\n// }\n//\n// const distanceThreshold = 20\n//\n// polygonCanvas.addEventListener('click', (event) => {\n//   if (!drawing) {\n//     return\n//   }\n//\n//   const point = [event.layerX, event.offsetY]\n//\n//   if (polygon.length >= 3 && distance(polygon[0], point) < distanceThreshold) {\n//     polygon.push(polygon[0])\n//     drawing = false\n//   } else {\n//     polygon.push(point)\n//   }\n//\n//   draw(polygon)\n// })\n//\n// document.getElementById('reset').addEventListener('click', () => {\n//   drawing = true\n//   polygon = []\n//   draw(polygon)\n// })\n//\n// document.getElementById('again').addEventListener('click', () => {\n//   startJiggling()\n// })\n\n\nfunction pixelBrightness (pixel) {\n  const r = pixel[0]\n  const g = pixel[1]\n  const b = pixel[2]\n\n  // https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\n  return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255\n}\n\nfunction distance (pointA, pointB) {\n  const dX = pointA[0] - pointB[0]\n  const dY = pointA[1] - pointB[1]\n  return Math.sqrt(Math.pow(dX, 2) + Math.pow(dY, 2))\n}\n\nfunction getLineColor (value, alpha=0.9) {\n  const r = Math.round(255 * value)\n  const g = Math.round(255 * (1 - value))\n  const b = 0\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`\n}\n\nfunction evaluateEdge (pointA, pointB, getPixel, fn, resolution) {\n\n  const length = distance(pointA, pointB)\n  const minumumSamples = Math.floor(length / resolution)\n\n  const usedResolution = length / (minumumSamples + 1)\n  const samples = Math.round(length / usedResolution)\n\n  const dX = pointB[0] - pointA[0]\n  const dY = pointB[1] - pointA[1]\n\n  const average = Array(samples + 1).fill(null)\n    .map((u, i) => i)\n    .map((i) => ([\n      pointA[0] + dX / samples * i,\n      pointA[1] + dY / samples * i\n    ]))\n    .map((point) => getPixel(point[0], point[1]))\n    .map(fn)\n    .reduce((total, score) => total + score) / (samples + 1)\n\n  return average\n}\n\nfunction evaluatePolygon (polygon, getPixel, fn, resolution) {\n  const edgeScores = Array(polygon.length - 1).fill(null)\n    .map((u, i) => i)\n    .map((index) => ([\n      polygon[index],\n      polygon[index + 1]\n    ]))\n    .map((edge) => evaluateEdge(edge[0], edge[1], getPixel, fn, resolution))\n\n  return edgeScores\n}\n\nfunction getRandomIndex (length) {\n  return Math.floor(Math.random() * ((length - 1) + 1))\n}\n\nfunction computeAverage (arr) {\n  return arr.reduce((total, score) => total + score) / arr.length\n}\n\nconst searchSize = 10\nconst resolution = 5\n\nfunction searchStep (polygon, getPixel, fn, resolution) {\n  const currentEdgeScores = evaluatePolygon(polygon, getPixel, fn, resolution)\n\n  const newPolygon = polygon.slice()\n  const moveIndex = getRandomIndex(newPolygon.length - 1)\n  const movePoint = newPolygon[moveIndex]\n\n  newPolygon[moveIndex] = [\n    movePoint[0] + searchSize * Math.random() - 0.5 * searchSize,\n    movePoint[1] + searchSize * Math.random() - 0.5 * searchSize\n  ]\n\n  if (moveIndex === 0) {\n    polygon[polygon.length - 1] = polygon[0]\n  }\n\n  const newEdgeScores = evaluatePolygon(newPolygon, getPixel, pixelBrightness, resolution)\n\n  if (computeAverage(newEdgeScores) < computeAverage(currentEdgeScores)) {\n    return {\n      polygon: newPolygon,\n      edgeScores: newEdgeScores\n    }\n  }\n}\n\nconst maxFailCount = 300\nconst maxSteps = 5000\nconst framerate = 30\n\nfunction startJiggling(vnode) {\n  console.log('Start jiggling!')\n\n  const getPixel = getBlurredPixel(vnode, 25)\n  const fn = pixelBrightness\n\n  let lastMessageTimestamp = 0\n\n  let failCount = 0\n  let successCount = 0\n\n  let step = 0\n  function jiggle () {\n    step += 1\n\n    const results = searchStep(vnode.state.data.polygon, getPixel, fn, 5)\n\n    if (results) {\n      failCount = 0\n\n      vnode.state.data.polygon = results.polygon\n      vnode.state.data.edgeScores = results.edgeScores\n      successCount += 1\n    } else {\n      failCount += 1\n    }\n\n    const timestamp = new Date().getTime()\n    if (timestamp - lastMessageTimestamp > (1000 / framerate)) {\n      m.redraw()\n      lastMessageTimestamp = timestamp\n    }\n\n    if (step < maxSteps && failCount < maxFailCount) {\n      setTimeout(jiggle, 1)\n    }\n  }\n\n  jiggle()\n}\n\nfunction getBlurredPixel (vnode, blurSize = 5) {\n  return function (x, y) {\n    const x1 = Math.max(0, Math.round(x - blurSize / 2))\n    const y1 = Math.max(0, Math.round(y - blurSize / 2))\n\n    const x2 = Math.min(vnode.state.data.dimensions.width, Math.round(x + blurSize / 2))\n    const y2 = Math.min(vnode.state.data.dimensions.height, Math.round(y + blurSize / 2))\n\n    const imageData = vnode.state.data.imageContext.getImageData(x1, y1, x2 - x1, y2 - y1)\n\n    const blurredPixelCount = imageData.data.length / 4\n    const average = Array(blurredPixelCount).fill(null)\n      .map((index) => ([\n        imageData.data[index * 4],\n        imageData.data[index * 4 + 1],\n        imageData.data[index * 4 + 2]\n      ]))\n      .reduce((total, color) => total.map((n, i) => n + color[i]), [0, 0, 0])\n      .map((n) => n / blurredPixelCount)\n\n    return average\n  }\n}\n\nfunction updateEdgeScore(vnode, index) {\n  if (index >= 0 && index < vnode.state.data.polygon.length - 1) {\n    const pointA = vnode.state.data.polygon[index]\n    const pointB = vnode.state.data.polygon[index + 1]\n    const getPixel = getBlurredPixel(vnode, 25)\n\n    const edgeScore = evaluateEdge(pointA, pointB, getPixel, pixelBrightness, 5)\n    vnode.state.data.edgeScores[index] = edgeScore\n  }\n}\n\nconst App = {\n  data: {\n    polygon: [],\n    edgeScores: [],\n    dimensions: {\n      width: 0,\n      height: 0\n    },\n    draggingIndex: -1,\n    draggingMoved: false,\n    jiggling: false,\n    drawing: false\n  },\n  view: (vnode) => ([\n    m('header', [\n      m('h1', 'Polygon Jiggler')\n    ]),\n    m('main', [\n      m('button', {\n        onclick: (event) => {\n          vnode.state.data.polygon = []\n          vnode.state.data.edgeScores = []\n        }\n      }, 'Reset'),\n      m('button', {\n        onclick: (event) => {\n          startJiggling(vnode)\n        }\n      }, 'Run!'),\n      m('div', {id: 'canvas-container'}, [\n        m('img', {\n          id: 'image',\n          src: IMAGE_URL,\n          onload: (event) => {\n            const img = event.target\n\n            vnode.state.data.dimensions = {\n              width: img.width,\n              height: img.height\n            }\n\n            const canvas = document.createElement('canvas')\n            canvas.width = img.width\n            canvas.height = img.height\n            const context = canvas.getContext('2d')\n            context.drawImage(img, 0, 0)\n            vnode.state.data.imageContext = context\n          }\n        }),\n        m('svg', {\n          id: 'polygon',\n          style: {\n            width: vnode.state.data.dimensions.width,\n            height: vnode.state.data.dimensions.height\n          },\n          onmousemove: (event) => {\n            if (vnode.state.data.draggingIndex === -1) {\n              event.redraw = false\n              return\n            }\n\n            vnode.state.data.draggingMoved = true\n\n            const point = [\n              event.offsetX,\n              event.offsetY\n            ]\n\n            vnode.state.data.polygon[vnode.state.data.draggingIndex] = point\n\n            updateEdgeScore(vnode, vnode.state.data.draggingIndex - 1)\n            updateEdgeScore(vnode, vnode.state.data.draggingIndex)\n          },\n          onmousedown: (event) => {\n            const point = [\n              event.offsetX,\n              event.offsetY\n            ]\n\n            vnode.state.data.polygon.push(point)\n            updateEdgeScore(vnode, vnode.state.data.polygon.length - 2)\n          }\n        }, [\n          m('g', {\n            id: 'polygon-edges'\n          }, vnode.state.data.polygon\n            .map((point, index) => m('line', {\n              x1: vnode.state.data.polygon[(index - 1 + vnode.state.data.polygon.length) % vnode.state.data.polygon.length][0],\n              y1: vnode.state.data.polygon[(index - 1 + vnode.state.data.polygon.length) % vnode.state.data.polygon.length][1],\n              x2: point[0],\n              y2: point[1],\n              stroke: getLineColor(vnode.state.data.edgeScores[index]),\n              onmousedown: (event) => {\n                const point = [\n                  event.offsetX,\n                  event.offsetY\n                ]\n\n                vnode.state.data.polygon.splice(index, 0, point)\n\n                vnode.state.data.edgeScores.splice(index - 1, 0, 0)\n                updateEdgeScore(vnode, index - 1)\n                updateEdgeScore(vnode, index)\n\n                vnode.state.data.draggingIndex = index\n                event.stopPropagation()\n              }\n            })\n          )),\n          m('g', {\n            id: 'polygon-vertices'\n          }, vnode.state.data.polygon\n            .map((point, index) => m('circle', {\n              cx: point[0],\n              cy: point[1],\n              r: 6,\n              onmousedown: (event) => {\n                vnode.state.data.draggingIndex = index\n                event.stopPropagation()\n              },\n              onmouseup: (event) => {\n                if (!vnode.state.data.draggingMoved && vnode.state.data.draggingIndex === index) {\n                  vnode.state.data.polygon.splice(index, 1)\n                }\n\n                vnode.state.data.draggingIndex = -1\n                vnode.state.data.draggingMoved = false\n                event.stopPropagation()\n              }\n            }))\n          )\n        ])\n      ])\n    ])\n  ])\n}\n\nm.mount(document.body, App)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJTUFHRV9VUkwgPSAnNTEwZDQ3ZTAtYmYzZS1hM2Q5LWUwNDAtZTAwYTE4MDY0YTk5LmpwZydcblxuLy9cbi8vXG4vLyBjb25zdCB1cmwgPSAnNTEwZDQ3ZTAtYmYzZS1hM2Q5LWUwNDAtZTAwYTE4MDY0YTk5LmpwZydcbi8vXG4vLyBjb25zdCBwb2x5Z29uQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BvbHlnb24tY2FudmFzJylcbi8vIGNvbnN0IHBvbHlnb25DdHggPSBwb2x5Z29uQ2FudmFzLmdldENvbnRleHQoJzJkJylcbi8vXG4vLyBjb25zdCBpbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1hZ2UnKVxuLy9cbi8vIGNvbnN0IGltZyA9IG5ldyBJbWFnZVxuLy9cbi8vIGxldCBpbWFnZUNhbnZhc1xuLy9cbi8vIGxldCB3b3JrZXJSdW5uaW5nID0gZmFsc2Vcbi8vXG4vLyBsZXQgcG9seWdvbiA9IFtdXG4vLyBsZXQgZHJhd2luZyA9IHRydWVcbi8vXG4vLyBsZXQgd29ya2VyXG4vL1xuLy8gZnVuY3Rpb24gc3RhcnRKaWdnbGluZyAoKSB7XG4vLyAgIHdvcmtlciA9IG5ldyBXb3JrZXIoJ3dvcmtlci5qcycpXG4vL1xuLy8gICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbi8vICAgICBjb25zb2xlLmVycm9yKGV2ZW50Lm1lc3NhZ2UpXG4vLyAgIH0pXG4vL1xuLy8gICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT4ge1xuLy8gICAgIGlmIChldmVudCAmJiBldmVudC5kYXRhKSB7XG4vLyAgICAgICBjb25zdCByZXN1bHRzID0gZXZlbnQuZGF0YVxuLy9cbi8vICAgICAgIHBvbHlnb24gPSBldmVudC5kYXRhLnBvbHlnb25cbi8vICAgICAgIGNvbnN0IHNjb3JlcyA9IGV2ZW50LmRhdGEuc2NvcmVzXG4vLyAgICAgICBkcmF3KHBvbHlnb24sIHNjb3Jlcylcbi8vICAgICB9IGVsc2Uge1xuLy8gICAgICAgd29ya2VyUnVubmluZyA9IGZhbHNlXG4vLyAgICAgfVxuLy8gICB9KVxuLy9cbi8vICAgY29uc3QgaW1hZ2VEYXRhID0gaW1hZ2VDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgaW1hZ2VDYW52YXMud2lkdGgsIGltYWdlQ2FudmFzLmhlaWdodClcbi8vICAgY29uc3QgYnVmZmVyID0gaW1hZ2VEYXRhLmRhdGEuYnVmZmVyXG4vL1xuLy8gICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuLy8gICAgIHN0ZXBDb3VudDogMTAwMCxcbi8vICAgICBidWZmZXIsXG4vLyAgICAgZGltZW5zaW9uczogW2ltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodF0sXG4vLyAgICAgcG9seWdvblxuLy8gICB9LCBbYnVmZmVyXSlcbi8vXG4vLyAgIHdvcmtlclJ1bm5pbmcgPSB0cnVlXG4vLyAgIC8vIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcClcbi8vIH1cbi8vXG4vLyAvLyBmdW5jdGlvbiBzdGVwICh0aW1lc3RhbXApIHtcbi8vIC8vICAgZHJhdyhwb2x5Z29uKVxuLy8gLy9cbi8vIC8vICAgaWYgKHJ1bm5pbmcpIHtcbi8vIC8vICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHN0ZXApXG4vLyAvLyAgIH1cbi8vIC8vIH1cbi8vXG4vLyBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbi8vICAgcG9seWdvbkNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0XG4vLyAgIHBvbHlnb25DYW52YXMud2lkdGggPSBpbWcud2lkdGhcbi8vXG4vLyAgIHBvbHlnb25DYW52YXMuc3R5bGUuaGVpZ2h0ID0gaW1nLmhlaWdodCArICdweCdcbi8vICAgcG9seWdvbkNhbnZhcy5zdHlsZS53aWR0aCA9IGltZy53aWR0aCArICdweCdcbi8vXG4vLyAgIGltYWdlRWxlbWVudC5zcmMgPSB1cmxcbi8vXG4vLyAgIGltYWdlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbi8vICAgaW1hZ2VDYW52YXMud2lkdGggPSBpbWcud2lkdGhcbi8vICAgaW1hZ2VDYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodFxuLy8gICBpbWFnZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWcsIDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodClcbi8vIH0pXG4vL1xuLy8gaW1nLnNyYyA9IHVybFxuLy9cbi8vIGZ1bmN0aW9uIGdldExpbmVDb2xvciAodmFsdWUsIGFscGhhPTAuOSkge1xuLy8gICBjb25zdCByID0gTWF0aC5yb3VuZCgyNTUgKiB2YWx1ZSlcbi8vICAgY29uc3QgZyA9IE1hdGgucm91bmQoMjU1ICogKDEgLSB2YWx1ZSkpXG4vLyAgIGNvbnN0IGIgPSAwXG4vLyAgIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2FscGhhfSlgXG4vLyB9XG4vL1xuLy8gZnVuY3Rpb24gZHJhdyAocG9seWdvbiwgc2NvcmVzKSB7XG4vLyAgIHBvbHlnb25DdHguY2xlYXJSZWN0KDAsIDAsIHBvbHlnb25DYW52YXMud2lkdGgsIHBvbHlnb25DYW52YXMuaGVpZ2h0KVxuLy9cbi8vICAgcG9seWdvbkN0eC5iZWdpblBhdGgoKVxuLy9cbi8vICAgY29uc3QgbGluZVdpZHRoID0gNVxuLy9cbi8vICAgcG9seWdvbkN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGhcbi8vICAgcG9seWdvbkN0eC5maWxsU3R5bGUgPSAncmVkJ1xuLy9cbi8vICAgaWYgKHBvbHlnb24ubGVuZ3RoID4gMSkge1xuLy8gICAgIHBvbHlnb24uc2xpY2UoMSlcbi8vICAgICAgIC5mb3JFYWNoKChwb2ludCwgaW5kZXgpID0+IHtcbi8vICAgICAgICAgaWYgKHNjb3JlcyAmJiBzY29yZXNbaW5kZXhdKSB7XG4vLyAgICAgICAgICAgcG9seWdvbkN0eC5zdHJva2VTdHlsZSA9IGdldExpbmVDb2xvcihzY29yZXNbaW5kZXhdKVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIHBvbHlnb25DdHguc3Ryb2tlU3R5bGUgPSAncmdiYSgwLCAwLCAwLCAwLjUpJ1xuLy8gICAgICAgICB9XG4vL1xuLy8gICAgICAgICBwb2x5Z29uQ3R4LmJlZ2luUGF0aCgpXG4vL1xuLy8gICAgICAgICBjb25zdCBwb2ludEEgPSBwb2x5Z29uW2luZGV4XVxuLy8gICAgICAgICBjb25zdCBwb2ludEIgPSBwb2x5Z29uW2luZGV4ICsgMV1cbi8vXG4vLyAgICAgICAgIHBvbHlnb25DdHgubW92ZVRvKHBvaW50QVswXSwgcG9pbnRBWzFdKVxuLy8gICAgICAgICBwb2x5Z29uQ3R4LmxpbmVUbyhwb2ludEJbMF0sIHBvaW50QlsxXSlcbi8vICAgICAgICAgcG9seWdvbkN0eC5zdHJva2UoKVxuLy8gICAgICAgfSlcbi8vICAgfVxuLy9cbi8vICAgcG9seWdvbkN0eC5saW5lV2lkdGggPSAwXG4vLyAgIHBvbHlnb25DdHguZmlsbFN0eWxlID0gJ2JsYWNrJ1xuLy9cbi8vICAgcG9seWdvbi5mb3JFYWNoKChwb2ludCkgPT4ge1xuLy8gICAgIHBvbHlnb25DdHguYmVnaW5QYXRoKClcbi8vICAgICBwb2x5Z29uQ3R4LmFyYyhwb2ludFswXSwgcG9pbnRbMV0sIGxpbmVXaWR0aCAqIDIsIDAsIDIgKiBNYXRoLlBJKVxuLy8gICAgIHBvbHlnb25DdHguZmlsbCgpXG4vLyAgIH0pXG4vL1xuLy8gICBwb2x5Z29uQ3R4LnN0cm9rZSgpXG4vLyB9XG4vL1xuLy8gZnVuY3Rpb24gZGlzdGFuY2UgKHBvaW50QSwgcG9pbnRCKSB7XG4vLyAgIGNvbnN0IGRYID0gcG9pbnRBWzBdIC0gcG9pbnRCWzBdXG4vLyAgIGNvbnN0IGRZID0gcG9pbnRBWzFdIC0gcG9pbnRCWzFdXG4vLyAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZFgsIDIpICsgTWF0aC5wb3coZFksIDIpKVxuLy8gfVxuLy9cbi8vIGNvbnN0IGRpc3RhbmNlVGhyZXNob2xkID0gMjBcbi8vXG4vLyBwb2x5Z29uQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4vLyAgIGlmICghZHJhd2luZykge1xuLy8gICAgIHJldHVyblxuLy8gICB9XG4vL1xuLy8gICBjb25zdCBwb2ludCA9IFtldmVudC5sYXllclgsIGV2ZW50Lm9mZnNldFldXG4vL1xuLy8gICBpZiAocG9seWdvbi5sZW5ndGggPj0gMyAmJiBkaXN0YW5jZShwb2x5Z29uWzBdLCBwb2ludCkgPCBkaXN0YW5jZVRocmVzaG9sZCkge1xuLy8gICAgIHBvbHlnb24ucHVzaChwb2x5Z29uWzBdKVxuLy8gICAgIGRyYXdpbmcgPSBmYWxzZVxuLy8gICB9IGVsc2Uge1xuLy8gICAgIHBvbHlnb24ucHVzaChwb2ludClcbi8vICAgfVxuLy9cbi8vICAgZHJhdyhwb2x5Z29uKVxuLy8gfSlcbi8vXG4vLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVzZXQnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbi8vICAgZHJhd2luZyA9IHRydWVcbi8vICAgcG9seWdvbiA9IFtdXG4vLyAgIGRyYXcocG9seWdvbilcbi8vIH0pXG4vL1xuLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FnYWluJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4vLyAgIHN0YXJ0SmlnZ2xpbmcoKVxuLy8gfSlcblxuXG5mdW5jdGlvbiBwaXhlbEJyaWdodG5lc3MgKHBpeGVsKSB7XG4gIGNvbnN0IHIgPSBwaXhlbFswXVxuICBjb25zdCBnID0gcGl4ZWxbMV1cbiAgY29uc3QgYiA9IHBpeGVsWzJdXG5cbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTk2MjE2L2Zvcm11bGEtdG8tZGV0ZXJtaW5lLWJyaWdodG5lc3Mtb2YtcmdiLWNvbG9yXG4gIHJldHVybiAoMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiKSAvIDI1NVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZSAocG9pbnRBLCBwb2ludEIpIHtcbiAgY29uc3QgZFggPSBwb2ludEFbMF0gLSBwb2ludEJbMF1cbiAgY29uc3QgZFkgPSBwb2ludEFbMV0gLSBwb2ludEJbMV1cbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkWCwgMikgKyBNYXRoLnBvdyhkWSwgMikpXG59XG5cbmZ1bmN0aW9uIGdldExpbmVDb2xvciAodmFsdWUsIGFscGhhPTAuOSkge1xuICBjb25zdCByID0gTWF0aC5yb3VuZCgyNTUgKiB2YWx1ZSlcbiAgY29uc3QgZyA9IE1hdGgucm91bmQoMjU1ICogKDEgLSB2YWx1ZSkpXG4gIGNvbnN0IGIgPSAwXG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2FscGhhfSlgXG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRWRnZSAocG9pbnRBLCBwb2ludEIsIGdldFBpeGVsLCBmbiwgcmVzb2x1dGlvbikge1xuXG4gIGNvbnN0IGxlbmd0aCA9IGRpc3RhbmNlKHBvaW50QSwgcG9pbnRCKVxuICBjb25zdCBtaW51bXVtU2FtcGxlcyA9IE1hdGguZmxvb3IobGVuZ3RoIC8gcmVzb2x1dGlvbilcblxuICBjb25zdCB1c2VkUmVzb2x1dGlvbiA9IGxlbmd0aCAvIChtaW51bXVtU2FtcGxlcyArIDEpXG4gIGNvbnN0IHNhbXBsZXMgPSBNYXRoLnJvdW5kKGxlbmd0aCAvIHVzZWRSZXNvbHV0aW9uKVxuXG4gIGNvbnN0IGRYID0gcG9pbnRCWzBdIC0gcG9pbnRBWzBdXG4gIGNvbnN0IGRZID0gcG9pbnRCWzFdIC0gcG9pbnRBWzFdXG5cbiAgY29uc3QgYXZlcmFnZSA9IEFycmF5KHNhbXBsZXMgKyAxKS5maWxsKG51bGwpXG4gICAgLm1hcCgodSwgaSkgPT4gaSlcbiAgICAubWFwKChpKSA9PiAoW1xuICAgICAgcG9pbnRBWzBdICsgZFggLyBzYW1wbGVzICogaSxcbiAgICAgIHBvaW50QVsxXSArIGRZIC8gc2FtcGxlcyAqIGlcbiAgICBdKSlcbiAgICAubWFwKChwb2ludCkgPT4gZ2V0UGl4ZWwocG9pbnRbMF0sIHBvaW50WzFdKSlcbiAgICAubWFwKGZuKVxuICAgIC5yZWR1Y2UoKHRvdGFsLCBzY29yZSkgPT4gdG90YWwgKyBzY29yZSkgLyAoc2FtcGxlcyArIDEpXG5cbiAgcmV0dXJuIGF2ZXJhZ2Vcbn1cblxuZnVuY3Rpb24gZXZhbHVhdGVQb2x5Z29uIChwb2x5Z29uLCBnZXRQaXhlbCwgZm4sIHJlc29sdXRpb24pIHtcbiAgY29uc3QgZWRnZVNjb3JlcyA9IEFycmF5KHBvbHlnb24ubGVuZ3RoIC0gMSkuZmlsbChudWxsKVxuICAgIC5tYXAoKHUsIGkpID0+IGkpXG4gICAgLm1hcCgoaW5kZXgpID0+IChbXG4gICAgICBwb2x5Z29uW2luZGV4XSxcbiAgICAgIHBvbHlnb25baW5kZXggKyAxXVxuICAgIF0pKVxuICAgIC5tYXAoKGVkZ2UpID0+IGV2YWx1YXRlRWRnZShlZGdlWzBdLCBlZGdlWzFdLCBnZXRQaXhlbCwgZm4sIHJlc29sdXRpb24pKVxuXG4gIHJldHVybiBlZGdlU2NvcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbUluZGV4IChsZW5ndGgpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICgobGVuZ3RoIC0gMSkgKyAxKSlcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUF2ZXJhZ2UgKGFycikge1xuICByZXR1cm4gYXJyLnJlZHVjZSgodG90YWwsIHNjb3JlKSA9PiB0b3RhbCArIHNjb3JlKSAvIGFyci5sZW5ndGhcbn1cblxuY29uc3Qgc2VhcmNoU2l6ZSA9IDEwXG5jb25zdCByZXNvbHV0aW9uID0gNVxuXG5mdW5jdGlvbiBzZWFyY2hTdGVwIChwb2x5Z29uLCBnZXRQaXhlbCwgZm4sIHJlc29sdXRpb24pIHtcbiAgY29uc3QgY3VycmVudEVkZ2VTY29yZXMgPSBldmFsdWF0ZVBvbHlnb24ocG9seWdvbiwgZ2V0UGl4ZWwsIGZuLCByZXNvbHV0aW9uKVxuXG4gIGNvbnN0IG5ld1BvbHlnb24gPSBwb2x5Z29uLnNsaWNlKClcbiAgY29uc3QgbW92ZUluZGV4ID0gZ2V0UmFuZG9tSW5kZXgobmV3UG9seWdvbi5sZW5ndGggLSAxKVxuICBjb25zdCBtb3ZlUG9pbnQgPSBuZXdQb2x5Z29uW21vdmVJbmRleF1cblxuICBuZXdQb2x5Z29uW21vdmVJbmRleF0gPSBbXG4gICAgbW92ZVBvaW50WzBdICsgc2VhcmNoU2l6ZSAqIE1hdGgucmFuZG9tKCkgLSAwLjUgKiBzZWFyY2hTaXplLFxuICAgIG1vdmVQb2ludFsxXSArIHNlYXJjaFNpemUgKiBNYXRoLnJhbmRvbSgpIC0gMC41ICogc2VhcmNoU2l6ZVxuICBdXG5cbiAgaWYgKG1vdmVJbmRleCA9PT0gMCkge1xuICAgIHBvbHlnb25bcG9seWdvbi5sZW5ndGggLSAxXSA9IHBvbHlnb25bMF1cbiAgfVxuXG4gIGNvbnN0IG5ld0VkZ2VTY29yZXMgPSBldmFsdWF0ZVBvbHlnb24obmV3UG9seWdvbiwgZ2V0UGl4ZWwsIHBpeGVsQnJpZ2h0bmVzcywgcmVzb2x1dGlvbilcblxuICBpZiAoY29tcHV0ZUF2ZXJhZ2UobmV3RWRnZVNjb3JlcykgPCBjb21wdXRlQXZlcmFnZShjdXJyZW50RWRnZVNjb3JlcykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcG9seWdvbjogbmV3UG9seWdvbixcbiAgICAgIGVkZ2VTY29yZXM6IG5ld0VkZ2VTY29yZXNcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbWF4RmFpbENvdW50ID0gMzAwXG5jb25zdCBtYXhTdGVwcyA9IDUwMDBcbmNvbnN0IGZyYW1lcmF0ZSA9IDMwXG5cbmZ1bmN0aW9uIHN0YXJ0SmlnZ2xpbmcodm5vZGUpIHtcbiAgY29uc29sZS5sb2coJ1N0YXJ0IGppZ2dsaW5nIScpXG5cbiAgY29uc3QgZ2V0UGl4ZWwgPSBnZXRCbHVycmVkUGl4ZWwodm5vZGUsIDI1KVxuICBjb25zdCBmbiA9IHBpeGVsQnJpZ2h0bmVzc1xuXG4gIGxldCBsYXN0TWVzc2FnZVRpbWVzdGFtcCA9IDBcblxuICBsZXQgZmFpbENvdW50ID0gMFxuICBsZXQgc3VjY2Vzc0NvdW50ID0gMFxuXG4gIGxldCBzdGVwID0gMFxuICBmdW5jdGlvbiBqaWdnbGUgKCkge1xuICAgIHN0ZXAgKz0gMVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IHNlYXJjaFN0ZXAodm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLCBnZXRQaXhlbCwgZm4sIDUpXG5cbiAgICBpZiAocmVzdWx0cykge1xuICAgICAgZmFpbENvdW50ID0gMFxuXG4gICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24gPSByZXN1bHRzLnBvbHlnb25cbiAgICAgIHZub2RlLnN0YXRlLmRhdGEuZWRnZVNjb3JlcyA9IHJlc3VsdHMuZWRnZVNjb3Jlc1xuICAgICAgc3VjY2Vzc0NvdW50ICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbENvdW50ICs9IDFcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgIGlmICh0aW1lc3RhbXAgLSBsYXN0TWVzc2FnZVRpbWVzdGFtcCA+ICgxMDAwIC8gZnJhbWVyYXRlKSkge1xuICAgICAgbS5yZWRyYXcoKVxuICAgICAgbGFzdE1lc3NhZ2VUaW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA8IG1heFN0ZXBzICYmIGZhaWxDb3VudCA8IG1heEZhaWxDb3VudCkge1xuICAgICAgc2V0VGltZW91dChqaWdnbGUsIDEpXG4gICAgfVxuICB9XG5cbiAgamlnZ2xlKClcbn1cblxuZnVuY3Rpb24gZ2V0Qmx1cnJlZFBpeGVsICh2bm9kZSwgYmx1clNpemUgPSA1KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh4IC0gYmx1clNpemUgLyAyKSlcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KDAsIE1hdGgucm91bmQoeSAtIGJsdXJTaXplIC8gMikpXG5cbiAgICBjb25zdCB4MiA9IE1hdGgubWluKHZub2RlLnN0YXRlLmRhdGEuZGltZW5zaW9ucy53aWR0aCwgTWF0aC5yb3VuZCh4ICsgYmx1clNpemUgLyAyKSlcbiAgICBjb25zdCB5MiA9IE1hdGgubWluKHZub2RlLnN0YXRlLmRhdGEuZGltZW5zaW9ucy5oZWlnaHQsIE1hdGgucm91bmQoeSArIGJsdXJTaXplIC8gMikpXG5cbiAgICBjb25zdCBpbWFnZURhdGEgPSB2bm9kZS5zdGF0ZS5kYXRhLmltYWdlQ29udGV4dC5nZXRJbWFnZURhdGEoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuXG4gICAgY29uc3QgYmx1cnJlZFBpeGVsQ291bnQgPSBpbWFnZURhdGEuZGF0YS5sZW5ndGggLyA0XG4gICAgY29uc3QgYXZlcmFnZSA9IEFycmF5KGJsdXJyZWRQaXhlbENvdW50KS5maWxsKG51bGwpXG4gICAgICAubWFwKChpbmRleCkgPT4gKFtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKiA0XSxcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKiA0ICsgMV0sXG4gICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICogNCArIDJdXG4gICAgICBdKSlcbiAgICAgIC5yZWR1Y2UoKHRvdGFsLCBjb2xvcikgPT4gdG90YWwubWFwKChuLCBpKSA9PiBuICsgY29sb3JbaV0pLCBbMCwgMCwgMF0pXG4gICAgICAubWFwKChuKSA9PiBuIC8gYmx1cnJlZFBpeGVsQ291bnQpXG5cbiAgICByZXR1cm4gYXZlcmFnZVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24ubGVuZ3RoIC0gMSkge1xuICAgIGNvbnN0IHBvaW50QSA9IHZub2RlLnN0YXRlLmRhdGEucG9seWdvbltpbmRleF1cbiAgICBjb25zdCBwb2ludEIgPSB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb25baW5kZXggKyAxXVxuICAgIGNvbnN0IGdldFBpeGVsID0gZ2V0Qmx1cnJlZFBpeGVsKHZub2RlLCAyNSlcblxuICAgIGNvbnN0IGVkZ2VTY29yZSA9IGV2YWx1YXRlRWRnZShwb2ludEEsIHBvaW50QiwgZ2V0UGl4ZWwsIHBpeGVsQnJpZ2h0bmVzcywgNSlcbiAgICB2bm9kZS5zdGF0ZS5kYXRhLmVkZ2VTY29yZXNbaW5kZXhdID0gZWRnZVNjb3JlXG4gIH1cbn1cblxuY29uc3QgQXBwID0ge1xuICBkYXRhOiB7XG4gICAgcG9seWdvbjogW10sXG4gICAgZWRnZVNjb3JlczogW10sXG4gICAgZGltZW5zaW9uczoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9LFxuICAgIGRyYWdnaW5nSW5kZXg6IC0xLFxuICAgIGRyYWdnaW5nTW92ZWQ6IGZhbHNlLFxuICAgIGppZ2dsaW5nOiBmYWxzZSxcbiAgICBkcmF3aW5nOiBmYWxzZVxuICB9LFxuICB2aWV3OiAodm5vZGUpID0+IChbXG4gICAgbSgnaGVhZGVyJywgW1xuICAgICAgbSgnaDEnLCAnUG9seWdvbiBKaWdnbGVyJylcbiAgICBdKSxcbiAgICBtKCdtYWluJywgW1xuICAgICAgbSgnYnV0dG9uJywge1xuICAgICAgICBvbmNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24gPSBbXVxuICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZWRnZVNjb3JlcyA9IFtdXG4gICAgICAgIH1cbiAgICAgIH0sICdSZXNldCcpLFxuICAgICAgbSgnYnV0dG9uJywge1xuICAgICAgICBvbmNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICBzdGFydEppZ2dsaW5nKHZub2RlKVxuICAgICAgICB9XG4gICAgICB9LCAnUnVuIScpLFxuICAgICAgbSgnZGl2Jywge2lkOiAnY2FudmFzLWNvbnRhaW5lcid9LCBbXG4gICAgICAgIG0oJ2ltZycsIHtcbiAgICAgICAgICBpZDogJ2ltYWdlJyxcbiAgICAgICAgICBzcmM6IElNQUdFX1VSTCxcbiAgICAgICAgICBvbmxvYWQ6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQudGFyZ2V0XG5cbiAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6IGltZy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpbWcuaGVpZ2h0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGhcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBpbWcuaGVpZ2h0XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgMClcbiAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuaW1hZ2VDb250ZXh0ID0gY29udGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG0oJ3N2ZycsIHtcbiAgICAgICAgICBpZDogJ3BvbHlnb24nLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICB3aWR0aDogdm5vZGUuc3RhdGUuZGF0YS5kaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB2bm9kZS5zdGF0ZS5kYXRhLmRpbWVuc2lvbnMuaGVpZ2h0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbm1vdXNlbW92ZTogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICBldmVudC5yZWRyYXcgPSBmYWxzZVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ01vdmVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IFtcbiAgICAgICAgICAgICAgZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICAgICAgZXZlbnQub2Zmc2V0WVxuICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb25bdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ0luZGV4XSA9IHBvaW50XG5cbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ0luZGV4IC0gMSlcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ0luZGV4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25tb3VzZWRvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBbXG4gICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFlcbiAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLnB1c2gocG9pbnQpXG4gICAgICAgICAgICB1cGRhdGVFZGdlU2NvcmUodm5vZGUsIHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5sZW5ndGggLSAyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgW1xuICAgICAgICAgIG0oJ2cnLCB7XG4gICAgICAgICAgICBpZDogJ3BvbHlnb24tZWRnZXMnXG4gICAgICAgICAgfSwgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uXG4gICAgICAgICAgICAubWFwKChwb2ludCwgaW5kZXgpID0+IG0oJ2xpbmUnLCB7XG4gICAgICAgICAgICAgIHgxOiB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb25bKGluZGV4IC0gMSArIHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5sZW5ndGgpICUgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aF1bMF0sXG4gICAgICAgICAgICAgIHkxOiB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb25bKGluZGV4IC0gMSArIHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5sZW5ndGgpICUgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aF1bMV0sXG4gICAgICAgICAgICAgIHgyOiBwb2ludFswXSxcbiAgICAgICAgICAgICAgeTI6IHBvaW50WzFdLFxuICAgICAgICAgICAgICBzdHJva2U6IGdldExpbmVDb2xvcih2bm9kZS5zdGF0ZS5kYXRhLmVkZ2VTY29yZXNbaW5kZXhdKSxcbiAgICAgICAgICAgICAgb25tb3VzZWRvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gW1xuICAgICAgICAgICAgICAgICAgZXZlbnQub2Zmc2V0WCxcbiAgICAgICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFlcbiAgICAgICAgICAgICAgICBdXG5cbiAgICAgICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24uc3BsaWNlKGluZGV4LCAwLCBwb2ludClcblxuICAgICAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZWRnZVNjb3Jlcy5zcGxpY2UoaW5kZXggLSAxLCAwLCAwKVxuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgaW5kZXggLSAxKVxuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgaW5kZXgpXG5cbiAgICAgICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLmRyYWdnaW5nSW5kZXggPSBpbmRleFxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSksXG4gICAgICAgICAgbSgnZycsIHtcbiAgICAgICAgICAgIGlkOiAncG9seWdvbi12ZXJ0aWNlcydcbiAgICAgICAgICB9LCB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb25cbiAgICAgICAgICAgIC5tYXAoKHBvaW50LCBpbmRleCkgPT4gbSgnY2lyY2xlJywge1xuICAgICAgICAgICAgICBjeDogcG9pbnRbMF0sXG4gICAgICAgICAgICAgIGN5OiBwb2ludFsxXSxcbiAgICAgICAgICAgICAgcjogNixcbiAgICAgICAgICAgICAgb25tb3VzZWRvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleCA9IGluZGV4XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25tb3VzZXVwOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdNb3ZlZCAmJiB2bm9kZS5zdGF0ZS5kYXRhLmRyYWdnaW5nSW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24uc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleCA9IC0xXG4gICAgICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ01vdmVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIF0pXG59XG5cbm0ubW91bnQoZG9jdW1lbnQuYm9keSwgQXBwKVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });