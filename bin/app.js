/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const IMAGE_URL = '510d47e0-bf3e-a3d9-e040-e00a18064a99.jpg'\nconst LINE_SAMPLE_RESOLUTION = 5\nconst SEARCH_SIZE = 20\n\nconst maxFailCount = 300\nconst maxSteps = 1000\nconst framerate = 30\n\nfunction pixelBrightness (pixel) {\n  const r = pixel[0]\n  const g = pixel[1]\n  const b = pixel[2]\n\n  // https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color\n  return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255\n}\n\nfunction distance (pointA, pointB) {\n  const dX = pointA[0] - pointB[0]\n  const dY = pointA[1] - pointB[1]\n  return Math.sqrt(Math.pow(dX, 2) + Math.pow(dY, 2))\n}\n\nfunction getLineColor (value, alpha=0.9) {\n  const r = Math.round(255 * value)\n  const g = Math.round(255 * (1 - value))\n  const b = 0\n  return `rgba(${r}, ${g}, ${b}, ${alpha})`\n}\n\nfunction evaluateEdge (pointA, pointB, getPixel, fn, resolution) {\n  const length = distance(pointA, pointB)\n\n  if (length === 0) {\n    return 0\n  }\n\n  const minumumSamples = Math.floor(length / resolution)\n\n  const usedResolution = length / (minumumSamples + 1)\n  const samples = Math.round(length / usedResolution)\n\n  const dX = pointB[0] - pointA[0]\n  const dY = pointB[1] - pointA[1]\n\n  const average = Array(samples + 1).fill(null)\n    .map((u, i) => i)\n    .map((i) => ([\n      pointA[0] + dX / samples * i,\n      pointA[1] + dY / samples * i\n    ]))\n    .map((point) => getPixel(point[0], point[1]))\n    .map(fn)\n    .reduce((total, score) => total + score) / (samples + 1)\n\n  return average\n}\n\nfunction evaluatePolygon (polygon, getPixel, fn, resolution) {\n  const edgeScores = Array(polygon.length).fill(null)\n    .map((u, i) => i)\n    .map((index) => ([\n      polygon[index],\n      polygon[(index + 1) % polygon.length]\n    ]))\n    .map((edge) => evaluateEdge(edge[0], edge[1], getPixel, fn, resolution))\n\n  return edgeScores\n}\n\nfunction getRandomIndex (length) {\n  return Math.floor(Math.random() * ((length - 1) + 1))\n}\n\nfunction computeAverage (arr) {\n  return arr.reduce((total, score) => total + score) / arr.length\n}\n\nfunction searchStep (polygon, dimensions, getPixel, fn, searchSize, resolution) {\n  const currentEdgeScores = evaluatePolygon(polygon, getPixel, fn, resolution)\n\n  const newPolygon = polygon.slice()\n  const moveIndex = getRandomIndex(newPolygon.length)\n  const movePoint = newPolygon[moveIndex]\n\n  newPolygon[moveIndex] = [\n    Math.min(Math.max(0, movePoint[0] + searchSize * Math.random() - 0.5 * searchSize), dimensions.width - 1),\n    Math.min(Math.max(0, movePoint[1] + searchSize * Math.random() - 0.5 * searchSize), dimensions.height - 1)\n  ]\n\n  const newEdgeScores = evaluatePolygon(newPolygon, getPixel, pixelBrightness, resolution)\n\n  if (computeAverage(newEdgeScores) < computeAverage(currentEdgeScores)) {\n    return {\n      polygon: newPolygon,\n      edgeScores: newEdgeScores\n    }\n  }\n}\n\nfunction startJiggling(vnode) {\n  console.log('Start jiggling!')\n\n  const getPixel = getBlurredPixel(vnode)\n  const fn = pixelBrightness\n\n  let lastMessageTimestamp = 0\n\n  let failCount = 0\n  let successCount = 0\n\n  let step = 0\n  function jiggle () {\n    step += 1\n\n    const results = searchStep(vnode.state.data.polygon, vnode.state.data.dimensions, getPixel, fn, SEARCH_SIZE, LINE_SAMPLE_RESOLUTION)\n\n    if (results) {\n      failCount = 0\n\n      vnode.state.data.polygon = results.polygon\n      vnode.state.data.edgeScores = results.edgeScores\n      successCount += 1\n    } else {\n      failCount += 1\n    }\n\n    const timestamp = new Date().getTime()\n    if (timestamp - lastMessageTimestamp > (1000 / framerate)) {\n      m.redraw()\n      lastMessageTimestamp = timestamp\n    }\n\n    if (step < maxSteps && failCount < maxFailCount) {\n      setTimeout(jiggle, 1)\n    } else {\n      console.log('Done!')\n      m.redraw()\n    }\n  }\n\n  jiggle()\n}\n\nfunction getBlurredPixel (vnode) {\n  const blurRadius = vnode.state.data.blurRadius\n\n  return function (x, y) {\n    const x1 = Math.max(0, Math.round(x - blurRadius / 2))\n    const y1 = Math.max(0, Math.round(y - blurRadius / 2))\n\n    const x2 = Math.min(vnode.state.data.dimensions.width - 1, Math.round(x + blurRadius / 2))\n    const y2 = Math.min(vnode.state.data.dimensions.height - 1, Math.round(y + blurRadius / 2))\n    // console.log(x1, y1, x2 - x1, y2 - y1)\n    const imageData = vnode.state.data.imageContext.getImageData(x1, y1, x2 - x1, y2 - y1)\n\n    const blurredPixelCount = imageData.data.length / 4\n    const average = Array(blurredPixelCount).fill(null)\n      .map((index) => ([\n        imageData.data[index * 4],\n        imageData.data[index * 4 + 1],\n        imageData.data[index * 4 + 2]\n      ]))\n      .reduce((total, color) => total.map((n, i) => n + color[i]), [0, 0, 0])\n      .map((n) => n / blurredPixelCount)\n\n    return average\n  }\n}\n\nfunction updateEdgeScore(vnode, index) {\n  index = (index + vnode.state.data.polygon.length) % vnode.state.data.polygon.length\n  if (index >= 0 && index < vnode.state.data.polygon.length ) {\n    const pointA = vnode.state.data.polygon[index]\n    const pointB = vnode.state.data.polygon[(index + 1) % vnode.state.data.polygon.length]\n    const getPixel = getBlurredPixel(vnode)\n\n    const edgeScore = evaluateEdge(pointA, pointB, getPixel, pixelBrightness, 5)\n    vnode.state.data.edgeScores[index] = edgeScore\n  }\n}\n\nconst App = {\n  data: {\n    polygon: [],\n    edgeScores: [],\n    dimensions: {\n      width: 0,\n      height: 0\n    },\n    draggingIndex: -1,\n    draggingMoved: false,\n    blurRadius: 25\n  },\n  view: (vnode) => ([\n    m('header', [\n      m('h1', 'Polygon Jiggler')\n    ]),\n    m('main', [\n      m('button', {\n        onclick: (event) => {\n          vnode.state.data.polygon = []\n          vnode.state.data.edgeScores = []\n        }\n      }, 'Reset'),\n      m('button', {\n        onclick: (event) => {\n          startJiggling(vnode, vnode.state.data.blurRadius)\n        }\n      }, 'Run!'),\n      m('input', {\n        type: 'range',\n        min: 1,\n        oninput: (event) => {\n          vnode.state.data.blurRadius = parseInt(event.target.value)\n          vnode.state.data.polygon.forEach((point, index) => {\n            updateEdgeScore(vnode, index)\n          })\n        }\n      }),\n      m('div', {id: 'canvas-container'}, [\n        m('img', {\n          id: 'image',\n          src: IMAGE_URL,\n          onload: (event) => {\n            const img = event.target\n\n            vnode.state.data.dimensions = {\n              width: img.width,\n              height: img.height\n            }\n\n            const canvas = document.createElement('canvas')\n            canvas.width = img.width\n            canvas.height = img.height\n            const context = canvas.getContext('2d')\n            context.drawImage(img, 0, 0)\n            vnode.state.data.imageContext = context\n          }\n        }),\n        m('svg', {\n          id: 'polygon',\n          style: {\n            width: vnode.state.data.dimensions.width,\n            height: vnode.state.data.dimensions.height\n          },\n          onmousemove: (event) => {\n            if (vnode.state.data.draggingIndex === -1) {\n              event.redraw = false\n              return\n            }\n\n            vnode.state.data.draggingMoved = true\n\n            const point = [\n              event.offsetX,\n              event.offsetY\n            ]\n\n            vnode.state.data.polygon[vnode.state.data.draggingIndex] = point\n\n            updateEdgeScore(vnode, vnode.state.data.draggingIndex - 1)\n            updateEdgeScore(vnode, vnode.state.data.draggingIndex)\n          },\n          onmousedown: (event) => {\n            const point = [\n              event.offsetX,\n              event.offsetY\n            ]\n\n            vnode.state.data.polygon.push(point)\n            updateEdgeScore(vnode, vnode.state.data.polygon.length - 1)\n            updateEdgeScore(vnode, vnode.state.data.polygon.length - 2)\n          }\n        }, [\n          m('g', {\n            id: 'polygon-edges'\n          }, vnode.state.data.polygon\n            .map((point, index) => m('line', {\n              x1: vnode.state.data.polygon[(index - 1 + vnode.state.data.polygon.length) % vnode.state.data.polygon.length][0],\n              y1: vnode.state.data.polygon[(index - 1 + vnode.state.data.polygon.length) % vnode.state.data.polygon.length][1],\n              x2: point[0],\n              y2: point[1],\n              stroke: getLineColor(vnode.state.data.edgeScores[(index - 1 + vnode.state.data.polygon.length) % vnode.state.data.polygon.length]),\n              onmousedown: (event) => {\n                const point = [\n                  event.offsetX,\n                  event.offsetY\n                ]\n\n                vnode.state.data.polygon.splice(index, 0, point)\n\n                vnode.state.data.edgeScores.splice(index - 1, 0, 0)\n                updateEdgeScore(vnode, index - 1)\n                updateEdgeScore(vnode, index)\n\n                vnode.state.data.draggingIndex = index\n                event.stopPropagation()\n              }\n            })\n          )),\n          m('g', {\n            id: 'polygon-vertices'\n          }, vnode.state.data.polygon\n            .map((point, index) => m('circle', {\n              cx: point[0],\n              cy: point[1],\n              r: 6,\n              onmousedown: (event) => {\n                vnode.state.data.draggingIndex = index\n                event.stopPropagation()\n              },\n              onmouseup: (event) => {\n                if (!vnode.state.data.draggingMoved && vnode.state.data.draggingIndex === index) {\n                  vnode.state.data.polygon.splice(index, 1)\n                  updateEdgeScore(vnode, index - 1)\n                }\n\n                vnode.state.data.draggingIndex = -1\n                vnode.state.data.draggingMoved = false\n                event.stopPropagation()\n              }\n            }))\n          )\n        ])\n      ])\n    ])\n  ])\n}\n\nm.mount(document.body, App)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJTUFHRV9VUkwgPSAnNTEwZDQ3ZTAtYmYzZS1hM2Q5LWUwNDAtZTAwYTE4MDY0YTk5LmpwZydcbmNvbnN0IExJTkVfU0FNUExFX1JFU09MVVRJT04gPSA1XG5jb25zdCBTRUFSQ0hfU0laRSA9IDIwXG5cbmNvbnN0IG1heEZhaWxDb3VudCA9IDMwMFxuY29uc3QgbWF4U3RlcHMgPSAxMDAwXG5jb25zdCBmcmFtZXJhdGUgPSAzMFxuXG5mdW5jdGlvbiBwaXhlbEJyaWdodG5lc3MgKHBpeGVsKSB7XG4gIGNvbnN0IHIgPSBwaXhlbFswXVxuICBjb25zdCBnID0gcGl4ZWxbMV1cbiAgY29uc3QgYiA9IHBpeGVsWzJdXG5cbiAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTk2MjE2L2Zvcm11bGEtdG8tZGV0ZXJtaW5lLWJyaWdodG5lc3Mtb2YtcmdiLWNvbG9yXG4gIHJldHVybiAoMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiKSAvIDI1NVxufVxuXG5mdW5jdGlvbiBkaXN0YW5jZSAocG9pbnRBLCBwb2ludEIpIHtcbiAgY29uc3QgZFggPSBwb2ludEFbMF0gLSBwb2ludEJbMF1cbiAgY29uc3QgZFkgPSBwb2ludEFbMV0gLSBwb2ludEJbMV1cbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkWCwgMikgKyBNYXRoLnBvdyhkWSwgMikpXG59XG5cbmZ1bmN0aW9uIGdldExpbmVDb2xvciAodmFsdWUsIGFscGhhPTAuOSkge1xuICBjb25zdCByID0gTWF0aC5yb3VuZCgyNTUgKiB2YWx1ZSlcbiAgY29uc3QgZyA9IE1hdGgucm91bmQoMjU1ICogKDEgLSB2YWx1ZSkpXG4gIGNvbnN0IGIgPSAwXG4gIHJldHVybiBgcmdiYSgke3J9LCAke2d9LCAke2J9LCAke2FscGhhfSlgXG59XG5cbmZ1bmN0aW9uIGV2YWx1YXRlRWRnZSAocG9pbnRBLCBwb2ludEIsIGdldFBpeGVsLCBmbiwgcmVzb2x1dGlvbikge1xuICBjb25zdCBsZW5ndGggPSBkaXN0YW5jZShwb2ludEEsIHBvaW50QilcblxuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuXG4gIGNvbnN0IG1pbnVtdW1TYW1wbGVzID0gTWF0aC5mbG9vcihsZW5ndGggLyByZXNvbHV0aW9uKVxuXG4gIGNvbnN0IHVzZWRSZXNvbHV0aW9uID0gbGVuZ3RoIC8gKG1pbnVtdW1TYW1wbGVzICsgMSlcbiAgY29uc3Qgc2FtcGxlcyA9IE1hdGgucm91bmQobGVuZ3RoIC8gdXNlZFJlc29sdXRpb24pXG5cbiAgY29uc3QgZFggPSBwb2ludEJbMF0gLSBwb2ludEFbMF1cbiAgY29uc3QgZFkgPSBwb2ludEJbMV0gLSBwb2ludEFbMV1cblxuICBjb25zdCBhdmVyYWdlID0gQXJyYXkoc2FtcGxlcyArIDEpLmZpbGwobnVsbClcbiAgICAubWFwKCh1LCBpKSA9PiBpKVxuICAgIC5tYXAoKGkpID0+IChbXG4gICAgICBwb2ludEFbMF0gKyBkWCAvIHNhbXBsZXMgKiBpLFxuICAgICAgcG9pbnRBWzFdICsgZFkgLyBzYW1wbGVzICogaVxuICAgIF0pKVxuICAgIC5tYXAoKHBvaW50KSA9PiBnZXRQaXhlbChwb2ludFswXSwgcG9pbnRbMV0pKVxuICAgIC5tYXAoZm4pXG4gICAgLnJlZHVjZSgodG90YWwsIHNjb3JlKSA9PiB0b3RhbCArIHNjb3JlKSAvIChzYW1wbGVzICsgMSlcblxuICByZXR1cm4gYXZlcmFnZVxufVxuXG5mdW5jdGlvbiBldmFsdWF0ZVBvbHlnb24gKHBvbHlnb24sIGdldFBpeGVsLCBmbiwgcmVzb2x1dGlvbikge1xuICBjb25zdCBlZGdlU2NvcmVzID0gQXJyYXkocG9seWdvbi5sZW5ndGgpLmZpbGwobnVsbClcbiAgICAubWFwKCh1LCBpKSA9PiBpKVxuICAgIC5tYXAoKGluZGV4KSA9PiAoW1xuICAgICAgcG9seWdvbltpbmRleF0sXG4gICAgICBwb2x5Z29uWyhpbmRleCArIDEpICUgcG9seWdvbi5sZW5ndGhdXG4gICAgXSkpXG4gICAgLm1hcCgoZWRnZSkgPT4gZXZhbHVhdGVFZGdlKGVkZ2VbMF0sIGVkZ2VbMV0sIGdldFBpeGVsLCBmbiwgcmVzb2x1dGlvbikpXG5cbiAgcmV0dXJuIGVkZ2VTY29yZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmFuZG9tSW5kZXggKGxlbmd0aCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKChsZW5ndGggLSAxKSArIDEpKVxufVxuXG5mdW5jdGlvbiBjb21wdXRlQXZlcmFnZSAoYXJyKSB7XG4gIHJldHVybiBhcnIucmVkdWNlKCh0b3RhbCwgc2NvcmUpID0+IHRvdGFsICsgc2NvcmUpIC8gYXJyLmxlbmd0aFxufVxuXG5mdW5jdGlvbiBzZWFyY2hTdGVwIChwb2x5Z29uLCBkaW1lbnNpb25zLCBnZXRQaXhlbCwgZm4sIHNlYXJjaFNpemUsIHJlc29sdXRpb24pIHtcbiAgY29uc3QgY3VycmVudEVkZ2VTY29yZXMgPSBldmFsdWF0ZVBvbHlnb24ocG9seWdvbiwgZ2V0UGl4ZWwsIGZuLCByZXNvbHV0aW9uKVxuXG4gIGNvbnN0IG5ld1BvbHlnb24gPSBwb2x5Z29uLnNsaWNlKClcbiAgY29uc3QgbW92ZUluZGV4ID0gZ2V0UmFuZG9tSW5kZXgobmV3UG9seWdvbi5sZW5ndGgpXG4gIGNvbnN0IG1vdmVQb2ludCA9IG5ld1BvbHlnb25bbW92ZUluZGV4XVxuXG4gIG5ld1BvbHlnb25bbW92ZUluZGV4XSA9IFtcbiAgICBNYXRoLm1pbihNYXRoLm1heCgwLCBtb3ZlUG9pbnRbMF0gKyBzZWFyY2hTaXplICogTWF0aC5yYW5kb20oKSAtIDAuNSAqIHNlYXJjaFNpemUpLCBkaW1lbnNpb25zLndpZHRoIC0gMSksXG4gICAgTWF0aC5taW4oTWF0aC5tYXgoMCwgbW92ZVBvaW50WzFdICsgc2VhcmNoU2l6ZSAqIE1hdGgucmFuZG9tKCkgLSAwLjUgKiBzZWFyY2hTaXplKSwgZGltZW5zaW9ucy5oZWlnaHQgLSAxKVxuICBdXG5cbiAgY29uc3QgbmV3RWRnZVNjb3JlcyA9IGV2YWx1YXRlUG9seWdvbihuZXdQb2x5Z29uLCBnZXRQaXhlbCwgcGl4ZWxCcmlnaHRuZXNzLCByZXNvbHV0aW9uKVxuXG4gIGlmIChjb21wdXRlQXZlcmFnZShuZXdFZGdlU2NvcmVzKSA8IGNvbXB1dGVBdmVyYWdlKGN1cnJlbnRFZGdlU2NvcmVzKSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb2x5Z29uOiBuZXdQb2x5Z29uLFxuICAgICAgZWRnZVNjb3JlczogbmV3RWRnZVNjb3Jlc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydEppZ2dsaW5nKHZub2RlKSB7XG4gIGNvbnNvbGUubG9nKCdTdGFydCBqaWdnbGluZyEnKVxuXG4gIGNvbnN0IGdldFBpeGVsID0gZ2V0Qmx1cnJlZFBpeGVsKHZub2RlKVxuICBjb25zdCBmbiA9IHBpeGVsQnJpZ2h0bmVzc1xuXG4gIGxldCBsYXN0TWVzc2FnZVRpbWVzdGFtcCA9IDBcblxuICBsZXQgZmFpbENvdW50ID0gMFxuICBsZXQgc3VjY2Vzc0NvdW50ID0gMFxuXG4gIGxldCBzdGVwID0gMFxuICBmdW5jdGlvbiBqaWdnbGUgKCkge1xuICAgIHN0ZXAgKz0gMVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IHNlYXJjaFN0ZXAodm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLCB2bm9kZS5zdGF0ZS5kYXRhLmRpbWVuc2lvbnMsIGdldFBpeGVsLCBmbiwgU0VBUkNIX1NJWkUsIExJTkVfU0FNUExFX1JFU09MVVRJT04pXG5cbiAgICBpZiAocmVzdWx0cykge1xuICAgICAgZmFpbENvdW50ID0gMFxuXG4gICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24gPSByZXN1bHRzLnBvbHlnb25cbiAgICAgIHZub2RlLnN0YXRlLmRhdGEuZWRnZVNjb3JlcyA9IHJlc3VsdHMuZWRnZVNjb3Jlc1xuICAgICAgc3VjY2Vzc0NvdW50ICs9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgZmFpbENvdW50ICs9IDFcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICAgIGlmICh0aW1lc3RhbXAgLSBsYXN0TWVzc2FnZVRpbWVzdGFtcCA+ICgxMDAwIC8gZnJhbWVyYXRlKSkge1xuICAgICAgbS5yZWRyYXcoKVxuICAgICAgbGFzdE1lc3NhZ2VUaW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA8IG1heFN0ZXBzICYmIGZhaWxDb3VudCA8IG1heEZhaWxDb3VudCkge1xuICAgICAgc2V0VGltZW91dChqaWdnbGUsIDEpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKCdEb25lIScpXG4gICAgICBtLnJlZHJhdygpXG4gICAgfVxuICB9XG5cbiAgamlnZ2xlKClcbn1cblxuZnVuY3Rpb24gZ2V0Qmx1cnJlZFBpeGVsICh2bm9kZSkge1xuICBjb25zdCBibHVyUmFkaXVzID0gdm5vZGUuc3RhdGUuZGF0YS5ibHVyUmFkaXVzXG5cbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgY29uc3QgeDEgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHggLSBibHVyUmFkaXVzIC8gMikpXG4gICAgY29uc3QgeTEgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKHkgLSBibHVyUmFkaXVzIC8gMikpXG5cbiAgICBjb25zdCB4MiA9IE1hdGgubWluKHZub2RlLnN0YXRlLmRhdGEuZGltZW5zaW9ucy53aWR0aCAtIDEsIE1hdGgucm91bmQoeCArIGJsdXJSYWRpdXMgLyAyKSlcbiAgICBjb25zdCB5MiA9IE1hdGgubWluKHZub2RlLnN0YXRlLmRhdGEuZGltZW5zaW9ucy5oZWlnaHQgLSAxLCBNYXRoLnJvdW5kKHkgKyBibHVyUmFkaXVzIC8gMikpXG4gICAgLy8gY29uc29sZS5sb2coeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuICAgIGNvbnN0IGltYWdlRGF0YSA9IHZub2RlLnN0YXRlLmRhdGEuaW1hZ2VDb250ZXh0LmdldEltYWdlRGF0YSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpXG5cbiAgICBjb25zdCBibHVycmVkUGl4ZWxDb3VudCA9IGltYWdlRGF0YS5kYXRhLmxlbmd0aCAvIDRcbiAgICBjb25zdCBhdmVyYWdlID0gQXJyYXkoYmx1cnJlZFBpeGVsQ291bnQpLmZpbGwobnVsbClcbiAgICAgIC5tYXAoKGluZGV4KSA9PiAoW1xuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCAqIDRdLFxuICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCAqIDQgKyAxXSxcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKiA0ICsgMl1cbiAgICAgIF0pKVxuICAgICAgLnJlZHVjZSgodG90YWwsIGNvbG9yKSA9PiB0b3RhbC5tYXAoKG4sIGkpID0+IG4gKyBjb2xvcltpXSksIFswLCAwLCAwXSlcbiAgICAgIC5tYXAoKG4pID0+IG4gLyBibHVycmVkUGl4ZWxDb3VudClcblxuICAgIHJldHVybiBhdmVyYWdlXG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRWRnZVNjb3JlKHZub2RlLCBpbmRleCkge1xuICBpbmRleCA9IChpbmRleCArIHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5sZW5ndGgpICUgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aFxuICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5sZW5ndGggKSB7XG4gICAgY29uc3QgcG9pbnRBID0gdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uW2luZGV4XVxuICAgIGNvbnN0IHBvaW50QiA9IHZub2RlLnN0YXRlLmRhdGEucG9seWdvblsoaW5kZXggKyAxKSAlIHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5sZW5ndGhdXG4gICAgY29uc3QgZ2V0UGl4ZWwgPSBnZXRCbHVycmVkUGl4ZWwodm5vZGUpXG5cbiAgICBjb25zdCBlZGdlU2NvcmUgPSBldmFsdWF0ZUVkZ2UocG9pbnRBLCBwb2ludEIsIGdldFBpeGVsLCBwaXhlbEJyaWdodG5lc3MsIDUpXG4gICAgdm5vZGUuc3RhdGUuZGF0YS5lZGdlU2NvcmVzW2luZGV4XSA9IGVkZ2VTY29yZVxuICB9XG59XG5cbmNvbnN0IEFwcCA9IHtcbiAgZGF0YToge1xuICAgIHBvbHlnb246IFtdLFxuICAgIGVkZ2VTY29yZXM6IFtdLFxuICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfSxcbiAgICBkcmFnZ2luZ0luZGV4OiAtMSxcbiAgICBkcmFnZ2luZ01vdmVkOiBmYWxzZSxcbiAgICBibHVyUmFkaXVzOiAyNVxuICB9LFxuICB2aWV3OiAodm5vZGUpID0+IChbXG4gICAgbSgnaGVhZGVyJywgW1xuICAgICAgbSgnaDEnLCAnUG9seWdvbiBKaWdnbGVyJylcbiAgICBdKSxcbiAgICBtKCdtYWluJywgW1xuICAgICAgbSgnYnV0dG9uJywge1xuICAgICAgICBvbmNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24gPSBbXVxuICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZWRnZVNjb3JlcyA9IFtdXG4gICAgICAgIH1cbiAgICAgIH0sICdSZXNldCcpLFxuICAgICAgbSgnYnV0dG9uJywge1xuICAgICAgICBvbmNsaWNrOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICBzdGFydEppZ2dsaW5nKHZub2RlLCB2bm9kZS5zdGF0ZS5kYXRhLmJsdXJSYWRpdXMpXG4gICAgICAgIH1cbiAgICAgIH0sICdSdW4hJyksXG4gICAgICBtKCdpbnB1dCcsIHtcbiAgICAgICAgdHlwZTogJ3JhbmdlJyxcbiAgICAgICAgbWluOiAxLFxuICAgICAgICBvbmlucHV0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLmJsdXJSYWRpdXMgPSBwYXJzZUludChldmVudC50YXJnZXQudmFsdWUpXG4gICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmZvckVhY2goKHBvaW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlRWRnZVNjb3JlKHZub2RlLCBpbmRleClcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIG0oJ2RpdicsIHtpZDogJ2NhbnZhcy1jb250YWluZXInfSwgW1xuICAgICAgICBtKCdpbWcnLCB7XG4gICAgICAgICAgaWQ6ICdpbWFnZScsXG4gICAgICAgICAgc3JjOiBJTUFHRV9VUkwsXG4gICAgICAgICAgb25sb2FkOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGltZyA9IGV2ZW50LnRhcmdldFxuXG4gICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgIHdpZHRoOiBpbWcud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaW1nLmhlaWdodFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoXG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodFxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApXG4gICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLmltYWdlQ29udGV4dCA9IGNvbnRleHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBtKCdzdmcnLCB7XG4gICAgICAgICAgaWQ6ICdwb2x5Z29uJyxcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHZub2RlLnN0YXRlLmRhdGEuZGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdm5vZGUuc3RhdGUuZGF0YS5kaW1lbnNpb25zLmhlaWdodFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25tb3VzZW1vdmU6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZXZlbnQucmVkcmF3ID0gZmFsc2VcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdNb3ZlZCA9IHRydWVcblxuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBbXG4gICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFlcbiAgICAgICAgICAgIF1cblxuICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uW3Zub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleF0gPSBwb2ludFxuXG4gICAgICAgICAgICB1cGRhdGVFZGdlU2NvcmUodm5vZGUsIHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleCAtIDEpXG4gICAgICAgICAgICB1cGRhdGVFZGdlU2NvcmUodm5vZGUsIHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleClcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9ubW91c2Vkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gW1xuICAgICAgICAgICAgICBldmVudC5vZmZzZXRYLFxuICAgICAgICAgICAgICBldmVudC5vZmZzZXRZXG4gICAgICAgICAgICBdXG5cbiAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEucG9seWdvbi5wdXNoKHBvaW50KVxuICAgICAgICAgICAgdXBkYXRlRWRnZVNjb3JlKHZub2RlLCB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aCAtIDIpXG4gICAgICAgICAgfVxuICAgICAgICB9LCBbXG4gICAgICAgICAgbSgnZycsIHtcbiAgICAgICAgICAgIGlkOiAncG9seWdvbi1lZGdlcydcbiAgICAgICAgICB9LCB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb25cbiAgICAgICAgICAgIC5tYXAoKHBvaW50LCBpbmRleCkgPT4gbSgnbGluZScsIHtcbiAgICAgICAgICAgICAgeDE6IHZub2RlLnN0YXRlLmRhdGEucG9seWdvblsoaW5kZXggLSAxICsgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aCkgJSB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24ubGVuZ3RoXVswXSxcbiAgICAgICAgICAgICAgeTE6IHZub2RlLnN0YXRlLmRhdGEucG9seWdvblsoaW5kZXggLSAxICsgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aCkgJSB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24ubGVuZ3RoXVsxXSxcbiAgICAgICAgICAgICAgeDI6IHBvaW50WzBdLFxuICAgICAgICAgICAgICB5MjogcG9pbnRbMV0sXG4gICAgICAgICAgICAgIHN0cm9rZTogZ2V0TGluZUNvbG9yKHZub2RlLnN0YXRlLmRhdGEuZWRnZVNjb3Jlc1soaW5kZXggLSAxICsgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLmxlbmd0aCkgJSB2bm9kZS5zdGF0ZS5kYXRhLnBvbHlnb24ubGVuZ3RoXSksXG4gICAgICAgICAgICAgIG9ubW91c2Vkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludCA9IFtcbiAgICAgICAgICAgICAgICAgIGV2ZW50Lm9mZnNldFgsXG4gICAgICAgICAgICAgICAgICBldmVudC5vZmZzZXRZXG4gICAgICAgICAgICAgICAgXVxuXG4gICAgICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLnNwbGljZShpbmRleCwgMCwgcG9pbnQpXG5cbiAgICAgICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLmVkZ2VTY29yZXMuc3BsaWNlKGluZGV4IC0gMSwgMCwgMClcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlU2NvcmUodm5vZGUsIGluZGV4IC0gMSlcbiAgICAgICAgICAgICAgICB1cGRhdGVFZGdlU2NvcmUodm5vZGUsIGluZGV4KVxuXG4gICAgICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ0luZGV4ID0gaW5kZXhcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICkpLFxuICAgICAgICAgIG0oJ2cnLCB7XG4gICAgICAgICAgICBpZDogJ3BvbHlnb24tdmVydGljZXMnXG4gICAgICAgICAgfSwgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uXG4gICAgICAgICAgICAubWFwKChwb2ludCwgaW5kZXgpID0+IG0oJ2NpcmNsZScsIHtcbiAgICAgICAgICAgICAgY3g6IHBvaW50WzBdLFxuICAgICAgICAgICAgICBjeTogcG9pbnRbMV0sXG4gICAgICAgICAgICAgIHI6IDYsXG4gICAgICAgICAgICAgIG9ubW91c2Vkb3duOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2bm9kZS5zdGF0ZS5kYXRhLmRyYWdnaW5nSW5kZXggPSBpbmRleFxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9ubW91c2V1cDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF2bm9kZS5zdGF0ZS5kYXRhLmRyYWdnaW5nTW92ZWQgJiYgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ0luZGV4ID09PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5wb2x5Z29uLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2VTY29yZSh2bm9kZSwgaW5kZXggLSAxKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZub2RlLnN0YXRlLmRhdGEuZHJhZ2dpbmdJbmRleCA9IC0xXG4gICAgICAgICAgICAgICAgdm5vZGUuc3RhdGUuZGF0YS5kcmFnZ2luZ01vdmVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICBdKVxuICAgIF0pXG4gIF0pXG59XG5cbm0ubW91bnQoZG9jdW1lbnQuYm9keSwgQXBwKVxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.js\n");

/***/ })

/******/ });